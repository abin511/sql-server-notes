/*检查当月从1号开始到目前为止，工作日内没有写日志，
系统补上前一天的日志内容，并且添加领导回复信息，
可以同时指定多个人员的工号进行添加日志，多个人员之间用英文逗号隔开
*/
USE [Booke.OA.Blog]
GO
CREATE PROCEDURE MS_P_IT_BTBLOG
@EMPCODES VARCHAR(512) /*102672,102672,102674*/
AS
SET NOCOUNT ON
/*自动给字符串加上逗号结尾*/
IF CHARINDEX(',',REVERSE(@EMPCODES)) <> 1 SET @EMPCODES = @EMPCODES+ ','
/*获取到目前位置的工作日*/
DECLARE @NOW DATETIME SET @NOW = CAST(CONVERT(CHAR(10),GETDATE(),23) AS DATETIME)
/*获取当月1号*/
DECLARE @DT CHAR(10) SET @DT = CAST(CONVERT(CHAR(7),@NOW,23) + '-01' AS DATETIME)
/*保存应该写日志的日期*/
DECLARE @TABLE TABLE(WORKTIME DATETIME)
INSERT INTO @TABLE
SELECT DATEADD(DAY,NUMBER,@DT) FROM MASTER..SPT_VALUES 
WHERE TYPE = 'P' AND DATEADD(DAY,NUMBER,@DT) < @NOW
AND DATEDIFF(MONTH,DATEADD(DAY,NUMBER,@DT),@DT) = 0
AND DATEPART(DW,DATEADD(DAY,NUMBER,@DT)) > 1 
AND DATEPART(DW,DATEADD(DAY,NUMBER,@DT)) < 7
/*原存储过程的变量*/
DECLARE @USERID INT
DECLARE @USERNAME VARCHAR(20)
DECLARE @ARTICLE VARCHAR(MAX)
DECLARE @ADVICE VARCHAR(MAX)
DECLARE @SUPERIORS INT
DECLARE @REASONS VARCHAR(MAX)
DECLARE @DEPIDPATH VARCHAR(512)
DECLARE @LEADERPATH VARCHAR(512)
DECLARE @COMMENTTABLE VARCHAR(32)
DECLARE @POSITIONID INT
DECLARE @POSITIONID_N INT
DECLARE @COMPANYID INT
DECLARE @EMOTIONLEADER INT 
DECLARE @REPLYCONTENT VARCHAR(MAX)
/*定义局部变量，用来操作个人的日志信息*/
DECLARE @EMPCODE VARCHAR(20)
DECLARE @BLOGID INT
DECLARE @KEY INT SET @KEY = 0
DECLARE @CTIME DATETIME
DECLARE @BLOGTABLE TABLE(ID INT IDENTITY(1,1),BLOGTIME DATETIME)
/*循环所有指定的人员，分别获取个人欠缺的日志日期*/
WHILE(CHARINDEX(',',@EMPCODES) > 0) BEGIN
	SET @EMPCODE = SUBSTRING(@EMPCODES,0,CHARINDEX(',',@EMPCODES))/*获取当个人员*/
	SET @EMPCODES = STUFF(@EMPCODES,1,CHARINDEX(',',@EMPCODES),'')
	/*获取未写日志的日期*/
	INSERT INTO @BLOGTABLE SELECT A.WORKTIME FROM @TABLE AS A LEFT JOIN
	(SELECT CAST(CONVERT(CHAR(10),ADDTIME,23) AS DATETIME) AS BLOGTIME FROM DBO.MS_T_BLOG WITH(NOLOCK) 
	WHERE DATEDIFF(MONTH,ADDTIME,@NOW) = 0 AND EMPCODE = @EMPCODE AND ADDTIME < @NOW) AS B
	ON A.WORKTIME = B.BLOGTIME WHERE B.BLOGTIME IS NULL
	/*获取未写日志的记录数*/
	DECLARE @CN INT SELECT @CN = COUNT(0) FROM @BLOGTABLE
	/*插入日志信息*/
	WHILE(@KEY < @CN) BEGIN
		SET @KEY = @KEY + 1
		SELECT @CTIME = BLOGTIME FROM @BLOGTABLE WHERE [ID] = @KEY
		/*查询未写日志的前一天的日志*/
		SELECT TOP 1 @USERID=USERID,@ARTICLE =ARTICLE,@ADVICE=ADVICE,@SUPERIORS=SUPERIORS,@REASONS=REASONS,@DEPIDPATH=DEPIDPATH,
		@LEADERPATH=LEADERPATH,@COMMENTTABLE=REPLYSTABLE,@POSITIONID=POSITIONID,@POSITIONID_N=POSITIONID_N,@EMPCODE=EMPCODE,
		@USERNAME=USERNAME,@COMPANYID=COMPANYID,@EMOTIONLEADER=EMOTIONLEADER,@REPLYCONTENT=REPLYCONTENT FROM DBO.MS_T_BLOG WITH(NOLOCK)
		WHERE EMPCODE = @EMPCODE AND ADDTIME < @CTIME ORDER BY ADDTIME DESC
		/*查询最后的领导回复信息*/
		IF( ISNULL(@REPLYCONTENT,'') = '') BEGIN
			SELECT @REPLYCONTENT=REPLYCONTENT FROM DBO.MS_T_BLOG WITH(NOLOCK)
			WHERE EMPCODE = @EMPCODE AND ADDTIME < @CTIME AND REPLYCONTENT IS NOT NULL ORDER BY REPLYDATE DESC
		END
		/*调用原存储过程插入日志*/
		EXEC [MS_P_IT_ADDBLOG] @USERID,@ARTICLE,@ADVICE,80,@SUPERIORS,@CTIME,@CTIME,@CTIME,@BLOGID OUTPUT,'|','0,',120,120,@REASONS,
		@DEPIDPATH,@LEADERPATH,@COMMENTTABLE,@POSITIONID,@POSITIONID_N,@USERNAME,0,0,@EMPCODE,1,@COMPANYID,@EMOTIONLEADER
		/*调用原存储过程回复日志*/
		SET @CTIME = DATEADD(N,10,@CTIME)
		EXEC [MS_P_IT_ADDBLOGREPLY] @SUPERIORS,@USERNAME,@BLOGID,@REPLYCONTENT,@CTIME,'|','0,',@BLOGID OUTPUT
	END
END
SET NOCOUNT OFF